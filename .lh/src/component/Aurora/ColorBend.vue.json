{
    "sourceFile": "src/component/Aurora/ColorBend.vue",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1768140451078,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1768140451078,
            "name": "Commit-0",
            "content": "<script setup lang=\"ts\">\r\nimport * as THREE from 'three';\r\nimport { onMounted, onBeforeUnmount, watch, ref, useTemplateRef, type CSSProperties } from 'vue';\r\n\r\ntype ColorBendsProps = {\r\n  className?: string;\r\n  style?: CSSProperties;\r\n  rotation?: number;\r\n  speed?: number;\r\n  colors?: string[];\r\n  transparent?: boolean;\r\n  autoRotate?: number;\r\n  scale?: number;\r\n  frequency?: number;\r\n  warpStrength?: number;\r\n  mouseInfluence?: number;\r\n  parallax?: number;\r\n  noise?: number;\r\n};\r\n\r\nconst MAX_COLORS = 8 as const;\r\n\r\nconst frag = `\r\n#define MAX_COLORS ${MAX_COLORS}\r\nuniform vec2 uCanvas;\r\nuniform float uTime;\r\nuniform float uSpeed;\r\nuniform vec2 uRot;\r\nuniform int uColorCount;\r\nuniform vec3 uColors[MAX_COLORS];\r\nuniform int uTransparent;\r\nuniform float uScale;\r\nuniform float uFrequency;\r\nuniform float uWarpStrength;\r\nuniform vec2 uPointer; // in NDC [-1,1]\r\nuniform float uMouseInfluence;\r\nuniform float uParallax;\r\nuniform float uNoise;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  float t = uTime * uSpeed;\r\n  vec2 p = vUv * 2.0 - 1.0;\r\n  p += uPointer * uParallax * 0.1;\r\n  vec2 rp = vec2(p.x * uRot.x - p.y * uRot.y, p.x * uRot.y + p.y * uRot.x);\r\n  vec2 q = vec2(rp.x * (uCanvas.x / uCanvas.y), rp.y);\r\n  q /= max(uScale, 0.0001);\r\n  q /= 0.5 + 0.2 * dot(q, q);\r\n  q += 0.2 * cos(t) - 7.56;\r\n  vec2 toward = (uPointer - rp);\r\n  q += toward * uMouseInfluence * 0.2;\r\n\r\n  vec3 col = vec3(0.0);\r\n  float a = 1.0;\r\n\r\n  if (uColorCount > 0) {\r\n    vec2 s = q;\r\n    vec3 sumCol = vec3(0.0);\r\n    float cover = 0.0;\r\n    for (int i = 0; i < MAX_COLORS; ++i) {\r\n      if (i >= uColorCount) break;\r\n      s -= 0.01;\r\n      vec2 r = sin(1.5 * (s.yx * uFrequency) + 2.0 * cos(s * uFrequency));\r\n      float m0 = length(r + sin(5.0 * r.y * uFrequency - 3.0 * t + float(i)) / 4.0);\r\n      float kBelow = clamp(uWarpStrength, 0.0, 1.0);\r\n      float kMix = pow(kBelow, 0.3);\r\n      float gain = 1.0 + max(uWarpStrength - 1.0, 0.0);\r\n      vec2 disp = (r - s) * kBelow;\r\n      vec2 warped = s + disp * gain;\r\n      float m1 = length(warped + sin(5.0 * warped.y * uFrequency - 3.0 * t + float(i)) / 4.0);\r\n      float m = mix(m0, m1, kMix);\r\n      float w = 1.0 - exp(-6.0 / exp(6.0 * m));\r\n      sumCol += uColors[i] * w;\r\n      cover = max(cover, w);\r\n    }\r\n    col = clamp(sumCol, 0.0, 1.0);\r\n    a = uTransparent > 0 ? cover : 1.0;\r\n  } else {\r\n    vec2 s = q;\r\n    for (int k = 0; k < 3; ++k) {\r\n      s -= 0.01;\r\n      vec2 r = sin(1.5 * (s.yx * uFrequency) + 2.0 * cos(s * uFrequency));\r\n      float m0 = length(r + sin(5.0 * r.y * uFrequency - 3.0 * t + float(k)) / 4.0);\r\n      float kBelow = clamp(uWarpStrength, 0.0, 1.0);\r\n      float kMix = pow(kBelow, 0.3);\r\n      float gain = 1.0 + max(uWarpStrength - 1.0, 0.0);\r\n      vec2 disp = (r - s) * kBelow;\r\n      vec2 warped = s + disp * gain;\r\n      float m1 = length(warped + sin(5.0 * warped.y * uFrequency - 3.0 * t + float(k)) / 4.0);\r\n      float m = mix(m0, m1, kMix);\r\n      col[k] = 1.0 - exp(-6.0 / exp(6.0 * m));\r\n    }\r\n    a = uTransparent > 0 ? max(max(col.r, col.g), col.b) : 1.0;\r\n  }\r\n\r\n  if (uNoise > 0.0001) {\r\n    float n = fract(sin(dot(gl_FragCoord.xy + vec2(uTime), vec2(12.9898, 78.233))) * 43758.5453123);\r\n    col += (n - 0.5) * uNoise;\r\n    col = clamp(col, 0.0, 1.0);\r\n  }\r\n\r\n  vec3 rgb = (uTransparent > 0) ? col * a : col;\r\n  gl_FragColor = vec4(rgb, a);\r\n}\r\n`;\r\n\r\nconst vert = `\r\nvarying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = vec4(position, 1.0);\r\n}\r\n`;\r\n\r\nconst props = withDefaults(defineProps<ColorBendsProps>(), {\r\n  rotation: 45,\r\n  speed: 0.2,\r\n  colors: () => [],\r\n  transparent: true,\r\n  autoRotate: 0,\r\n  scale: 1,\r\n  frequency: 1,\r\n  warpStrength: 1,\r\n  mouseInfluence: 1,\r\n  parallax: 0.5,\r\n  noise: 0.1\r\n});\r\n\r\nconst containerRef = useTemplateRef('containerRef');\r\nconst rendererRef = ref<THREE.WebGLRenderer | null>(null);\r\nconst rafRef = ref<number | null>(null);\r\nconst materialRef = ref<THREE.ShaderMaterial | null>(null);\r\nconst resizeObserverRef = ref<ResizeObserver | null>(null);\r\nconst rotationRef = ref(props.rotation);\r\nconst autoRotateRef = ref(props.autoRotate);\r\nconst pointerTargetRef = ref(new THREE.Vector2(0, 0));\r\nconst pointerCurrentRef = ref(new THREE.Vector2(0, 0));\r\nconst pointerSmoothRef = ref(8);\r\n\r\nlet cleanup: (() => void) | null = null;\r\n\r\nconst setup = () => {\r\n  const container = containerRef.value!;\r\n  const scene = new THREE.Scene();\r\n  const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\r\n\r\n  const geometry = new THREE.PlaneGeometry(2, 2);\r\n  const uColorsArray = Array.from({ length: MAX_COLORS }, () => new THREE.Vector3(0, 0, 0));\r\n\r\n  const material = new THREE.ShaderMaterial({\r\n    vertexShader: vert,\r\n    fragmentShader: frag,\r\n    uniforms: {\r\n      uCanvas: { value: new THREE.Vector2(1, 1) },\r\n      uTime: { value: 0 },\r\n      uSpeed: { value: props.speed },\r\n      uRot: { value: new THREE.Vector2(1, 0) },\r\n      uColorCount: { value: 0 },\r\n      uColors: { value: uColorsArray },\r\n      uTransparent: { value: props.transparent ? 1 : 0 },\r\n      uScale: { value: props.scale },\r\n      uFrequency: { value: props.frequency },\r\n      uWarpStrength: { value: props.warpStrength },\r\n      uPointer: { value: new THREE.Vector2(0, 0) },\r\n      uMouseInfluence: { value: props.mouseInfluence },\r\n      uParallax: { value: props.parallax },\r\n      uNoise: { value: props.noise }\r\n    },\r\n    premultipliedAlpha: true,\r\n    transparent: true\r\n  });\r\n  materialRef.value = material;\r\n\r\n  const mesh = new THREE.Mesh(geometry, material);\r\n  scene.add(mesh);\r\n\r\n  const renderer = new THREE.WebGLRenderer({\r\n    antialias: false,\r\n    powerPreference: 'high-performance',\r\n    alpha: true\r\n  });\r\n  rendererRef.value = renderer;\r\n  (renderer as any).outputColorSpace = (THREE as any).SRGBColorSpace;\r\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\r\n  renderer.setClearColor(0x000000, props.transparent ? 0 : 1);\r\n  renderer.domElement.style.width = '100%';\r\n  renderer.domElement.style.height = '100%';\r\n  renderer.domElement.style.display = 'block';\r\n  container.appendChild(renderer.domElement);\r\n\r\n  const clock = new THREE.Clock();\r\n\r\n  const handleResize = () => {\r\n    const w = container.clientWidth || 1;\r\n    const h = container.clientHeight || 1;\r\n    renderer.setSize(w, h, false);\r\n    (material.uniforms.uCanvas.value as THREE.Vector2).set(w, h);\r\n  };\r\n\r\n  handleResize();\r\n\r\n  if ('ResizeObserver' in window) {\r\n    const ro = new ResizeObserver(handleResize);\r\n    ro.observe(container);\r\n    resizeObserverRef.value = ro;\r\n  } else {\r\n    (window as any).addEventListener('resize', handleResize);\r\n  }\r\n\r\n  const loop = () => {\r\n    const dt = clock.getDelta();\r\n    const elapsed = clock.elapsedTime;\r\n    material.uniforms.uTime.value = elapsed;\r\n\r\n    const deg = (rotationRef.value % 360) + autoRotateRef.value * elapsed;\r\n    const rad = (deg * Math.PI) / 180;\r\n    const c = Math.cos(rad);\r\n    const s = Math.sin(rad);\r\n    (material.uniforms.uRot.value as THREE.Vector2).set(c, s);\r\n\r\n    const cur = pointerCurrentRef.value;\r\n    const tgt = pointerTargetRef.value;\r\n    const amt = Math.min(1, dt * pointerSmoothRef.value);\r\n    cur.lerp(tgt, amt);\r\n    (material.uniforms.uPointer.value as THREE.Vector2).copy(cur);\r\n    renderer.render(scene, camera);\r\n    rafRef.value = requestAnimationFrame(loop);\r\n  };\r\n  rafRef.value = requestAnimationFrame(loop);\r\n\r\n  const handlePointerMove = (e: PointerEvent) => {\r\n    const rect = container.getBoundingClientRect();\r\n    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;\r\n    const y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);\r\n    pointerTargetRef.value.set(x, y);\r\n  };\r\n\r\n  container.addEventListener('pointermove', handlePointerMove);\r\n\r\n  cleanup = () => {\r\n    if (rafRef.value !== null) cancelAnimationFrame(rafRef.value);\r\n    if (resizeObserverRef.value) resizeObserverRef.value.disconnect();\r\n    else window.removeEventListener('resize', handleResize);\r\n    container.removeEventListener('pointermove', handlePointerMove);\r\n    geometry.dispose();\r\n    material.dispose();\r\n    renderer.dispose();\r\n    if (renderer.domElement && renderer.domElement.parentElement === container) {\r\n      container.removeChild(renderer.domElement);\r\n    }\r\n  };\r\n};\r\n\r\nonMounted(setup);\r\nonBeforeUnmount(() => cleanup?.());\r\n\r\nwatch(\r\n  () => ({ ...props }),\r\n  () => {\r\n    const material = materialRef.value;\r\n    const renderer = rendererRef.value;\r\n    if (!material) return;\r\n\r\n    rotationRef.value = props.rotation;\r\n    autoRotateRef.value = props.autoRotate;\r\n    material.uniforms.uSpeed.value = props.speed;\r\n    material.uniforms.uScale.value = props.scale;\r\n    material.uniforms.uFrequency.value = props.frequency;\r\n    material.uniforms.uWarpStrength.value = props.warpStrength;\r\n    material.uniforms.uMouseInfluence.value = props.mouseInfluence;\r\n    material.uniforms.uParallax.value = props.parallax;\r\n    material.uniforms.uNoise.value = props.noise;\r\n\r\n    const toVec3 = (hex: string) => {\r\n      const h = hex.replace('#', '').trim();\r\n      const v =\r\n        h.length === 3\r\n          ? [parseInt(h[0] + h[0], 16), parseInt(h[1] + h[1], 16), parseInt(h[2] + h[2], 16)]\r\n          : [parseInt(h.slice(0, 2), 16), parseInt(h.slice(2, 4), 16), parseInt(h.slice(4, 6), 16)];\r\n      return new THREE.Vector3(v[0] / 255, v[1] / 255, v[2] / 255);\r\n    };\r\n\r\n    const arr = (props.colors || []).filter(Boolean).slice(0, MAX_COLORS).map(toVec3);\r\n    for (let i = 0; i < MAX_COLORS; i++) {\r\n      const vec = (material.uniforms.uColors.value as THREE.Vector3[])[i];\r\n      if (i < arr.length) vec.copy(arr[i]);\r\n      else vec.set(0, 0, 0);\r\n    }\r\n    material.uniforms.uColorCount.value = arr.length;\r\n\r\n    material.uniforms.uTransparent.value = props.transparent ? 1 : 0;\r\n    if (renderer) renderer.setClearColor(0x000000, props.transparent ? 0 : 1);\r\n  },\r\n  { deep: true }\r\n);\r\n</script>\r\n\r\n<template>\r\n  <div ref=\"containerRef\" :class=\"['w-full h-full relative overflow-hidden', props.className]\" :style=\"props.style\" />\r\n</template>\r\n"
        }
    ]
}